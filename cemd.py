#!/usr/bin/env python3

"""
Author: Bing-Liang Leng
E-mail: leng.bl@sjtu.edu.cn

This script converts a Velox generated .emd file into images or .msa file (for spectrum)

Usage:
  cemd.py -f INPUT_FILE

Run "cemd.py -h" for more information
"""

import os
import argparse
import hyperspy.api as hs
from skimage import exposure, img_as_ubyte
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

def transparent_single_color_cmap(color):
    return mcolors.LinearSegmentedColormap.from_list(
        "", [mcolors.to_rgba(color, 0), mcolors.to_rgba(color, 1)]
    )

def draw_scale_bar(frame, size_x, size_y, width_factor, sb_color):
    sb_lst = [0.1,0.2,0.5,1,2,5,10,20,50,100,200,500,1000,2000,5000]
    scale = frame.axes_manager[0].scale
    unit = frame.axes_manager[0].units
    sb_len_float = size_x * scale / 6
    sb_len = sorted(sb_lst, key=lambda a: abs(a - sb_len_float))[0]
    sb_len_px = sb_len / scale
    sb_start_x, sb_start_y, sb_width = (size_x * sb_x_start , size_y * sb_y_start, size_y / width_factor)
    return [plt.Rectangle((sb_start_x, sb_start_y), sb_len_px, sb_width, color=sb_color, fill=True), "_" + str(sb_len) + unit]
    

def convert_emd():
    output_dir = file + "/"
    output_name = output_dir + file + "_"
    data = list(hs.load(file + ".emd"))

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    mapping_frame = []
    overlay = False

    for i in range(len(data)):
        frame = data[i]
        dim = frame.axes_manager.signal_dimension
        title = frame.metadata.General.title

        if dim == 2:
            rescale_data = exposure.rescale_intensity(frame.data, in_range=intensity_range)
            if ada_equ:
                uimg = img_as_ubyte(exposure.equalize_adapthist(rescale_data, clip_limit=contrast))
            else:
                uimg = img_as_ubyte(rescale_data)
            img = Image.fromarray(uimg)

            cmp = "gray"
            if title in eds_color:
                cmp = transparent_single_color_cmap(eds_color.get(title))
                if title in mapping_overlay:
                    mapping_frame.append([title, img])
                    overlay = True
            elif overlay and title == "HAADF":
                mapping_frame.append([title, img])
                HADDF_frame_num = len(mapping_frame) - 1
                HADDF_frame = frame
            
            size_x, size_y = img.size
            plt.figure(figsize=(size_x/100, size_y/100), facecolor="black")
            ax = plt.gca()
            plt.imshow(img, cmap=cmp)

            if scale_bar == True:
                bar = draw_scale_bar(frame, size_x, size_y, sb_width_factor, sb_color)
                ax.add_patch(bar[0])
                sb_text = bar[1]
            
            plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
            plt.margins = (0, 0)
            plt.axis("off")
            if scale_bar == True:
                plt.savefig(output_name + title + "_" + str(i) + sb_text + output_type)
            else:
                plt.savefig(output_name + title + "_" + str(i) + output_type)
            plt.close()

        elif dim == 1:
            frame.sum().save(output_name + title + "_" + str(i) + ".msa", overwrite = True)

    if overlay:
        element = ""
        size_x, size_y = mapping_frame[HADDF_frame_num][1].size

        plt.figure(figsize=(size_x/100, size_y/100), facecolor="black")
        ax = plt.gca()
        plt.imshow(mapping_frame[HADDF_frame_num][1], cmap="gray", alpha=sub_alpha)
        for i in range(len(mapping_frame)):
            if i == HADDF_frame_num:
                continue
            plt.imshow(mapping_frame[i][1], cmap=transparent_single_color_cmap(eds_color.get(mapping_frame[i][0])), alpha=overlay_alpha)
            element = element + "_" + mapping_frame[i][0]
        
        if scale_bar == True:
            bar = draw_scale_bar(HADDF_frame, size_x, size_y, sb_width_factor, sb_color)
            ax.add_patch(bar[0])
            sb_text = bar[1]

        plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
        plt.margins = (0, 0)
        plt.axis("off")
        if scale_bar == True:
            plt.savefig(output_name + "Overlay" + element + sb_text + output_type)
        else:
            plt.savefig(output_name + "Overlay" + element + output_type)
        plt.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = "Convert .emd file generated by Velox  to images")
    parser.add_argument("-f", "--file", type = str, metavar = "FILE", help = "Input *.emd(Velox) filename (without \".emd\" extension)", required=True)
    parser.add_argument("-o", "--out", type = str, metavar = "TYPE", help = "Type of output images.", default = "png")
    parser.add_argument("-ns", "--no_scale", help = "Do not draw scale bar", action = "store_true")
    parser.add_argument("-sc", "--scale_color", type = str, metavar = "COLOR", help = "Color of scale bar", default = "#ffffff")
    parser.add_argument("-s", "--scale", type = float, nargs = 3, metavar = "FLOAT", help = "The position and width of scale bar (X_POSITION Y_POSITION WIDTH_FACTOR), the width is set as image-height/WIDTH_FACTOR", default = [0.75, 0.9167, 150.0])
    parser.add_argument("-e", "--eds", type = str, nargs = "+", metavar = "Str", help = "The color of elemental mappings (default: gray)", default = [])
    parser.add_argument("-oe", "--overlay", type = str, nargs = "+", metavar = "ELEMENT", help = "The elements for overlayed mapping", default = [])
    parser.add_argument("-oa", "--overlay_alpha", type = float, metavar = "ALPHA", help = "Transparency of the overlayed elemental mapping (a value between 0 and 1, 0 means totally transparent)", default = "1.0")
    parser.add_argument("-sa", "--substrate_alpha", type = float, metavar = "ALPHA", help = "Transparency of the HAADF substrate picture in elemental mapping (a value between 0 and 1, 0 means totally transparent).", default = "0.5")
    parser.add_argument("-c", "--contrast", type = float, metavar = "CONTRAST", help = "The image contrast (a value between 0 and 1, 1 means highest contrast)", default = None)
    parser.add_argument("-i", "--intensity_range", type = int, nargs = 2, metavar = "INT", help = "The intensity range of pixels. Use this to deal with noise-induced low contrast (\"0 7000\" for example).", default = None)    
    args = parser.parse_args()

    file = args.file
    output_type = "." + args.out

    if args.no_scale:
        scale_bar = False
    else: scale_bar = True

    sb_color = args.scale_color
    sb_x_start = args.scale[0]
    sb_y_start = args.scale[1]
    sb_width_factor = args.scale[2]

    if args.contrast is None:
        ada_equ = False
    else:
        ada_equ = True
        contrast = args.contrast

    if args.intensity_range is None:
        intensity_range = "image"
    else: intensity_range = (args.intensity_range[0], args.intensity_range[1])

    overlay_alpha = args.overlay_alpha
    sub_alpha = args.substrate_alpha
    eds_color = {}
    for i in range(int(len(args.eds)/2)):
        ele = i * 2
        ele_color = ele + 1
        eds_color[args.eds[ele]] = args.eds[ele_color]
    mapping_overlay = args.overlay

    convert_emd()